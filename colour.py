# This file is a derivation of work on - and as such shares the same
# licence as - Linux Show Player
#
# Linux Show Player:
#   Copyright 2012-2022 Francesco Ceruti <ceppofrancy@gmail.com>
#
# This file:
#   Copyright 2022 s0600204
#
# Linux Show Player is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Linux Show Player is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Linux Show Player.  If not, see <http://www.gnu.org/licenses/>.

"""
Whilst LiSP can display its cues using any colour of the rainbow, QLab cannot. Instead, it has
a palette of (no doubt carefully chosen) colours that users may choose from.

Thus, we need to map a user's arbitrary cue colour choice to one contained within QLab's
palette.

Instead of comparing against every possible colour QLab uses, we instead use a "k-dimensional
tree" to store values in, which allows us to take a divide-and-conquer approach to finding the
nearest palette colour.

The k-d tree is generated by hand, as the colour range used by QLab is simple (thus easy for a
human to generate) and does not change mid-program (so we don't need to add, insert, or remove
entries programmatically).

Links:
* https://en.wikipedia.org/wiki/K-d_tree
* https://en.wikipedia.org/wiki/Euclidean_distance
* https://qlab.app/docs/v4/scripting/osc-dictionary-v4/#cuecue_numbercolorname-string
"""

# The colours QLab uses.
#
# Names were initially discovered by comparing against the list of colours compiled by Randall
# Munroe (of xkcd), obtainable from https://blog.xkcd.com/2010/05/03/color-survey-results/
# (License: CC-0).
#
# Further colours were discovered by finding a screenshot online that claimed to show them:
# https://alspr.tumblr.com/post/173661838363/turns-out-qlab-has-a-bunch-of-hidden-colors-up
#
# Regrettably that screenshot suffers from jpeg artifacts, making accurate RGB value extraction
# difficult. Thus a computer capable of running QLab was located, and a fresh screenshot (in
# lossless PNG format) was created. The RGB values below are taken from that.
#
# Note: We don't provide a value for QLab colour 'none', as that's unnecessary - if a user
#       hasn't set (or has cleared) a colour in LiSP, then `find_nearest_colour()` isn't called.
AVOCADO      = ((103, 146,   0), 'avocado')
BASTARDAMBER = ((255, 210, 193), 'bastardamber')
BISQUE       = ((255, 233, 207), 'bisque')
BLUE         = (( 82, 115, 224), 'blue')
CELADON      = ((185, 229, 189), 'celadon')
CERULEAN     = ((  0, 142, 182), 'cerulean')
CHARTREUSE   = ((228, 251,   0), 'chartreuse')
CORAL        = ((255, 147,  97), 'coral')
ECRU         = ((206, 190, 146), 'ecru')
FUCHSIA      = ((255, 101, 255), 'fuchsia')
FULVOUS      = ((235, 151,   0), 'fulvous')
GLAUCOUS     = ((113, 146, 192), 'glaucous')
GREEN        = ((  0, 209,  46), 'green')
GREY         = ((160, 156, 169), 'grey')
INDIGO       = ((110, 106, 169), 'indigo')
LILAC        = ((206, 176, 206), 'lilac')
MAIZE        = ((249, 234, 111), 'maize')
MAUVE        = ((231, 193, 255), 'mauve')
OCHRE        = ((215, 138,  44), 'ochre')
OLIVE        = ((146, 144,   0), 'olive')
ORANGE       = ((255, 166,   0), 'orange')
PUCE         = ((215, 155, 169), 'puce')
PURPLE       = ((169,  43, 192), 'purple')
RED          = ((255,  76,  66), 'red')
RUFOUS       = ((185,  46,   2), 'rufous')
SAGE         = ((200, 195, 156), 'sage')
SCARLET      = ((255,  65,  68), 'scarlet')
SEAFOAMGREEN = ((205, 230, 202), 'seafoamgreen')
SKYBLUE      = ((151, 216, 239), 'skyblue')
TAUPE        = ((192, 156, 127), 'taupe')
VERDIGRIS    = (( 81, 190, 188), 'verdigris')
VERMILION    = ((235,  91,  67), 'vermilion')
VIRIDIAN     = (( 80, 146, 127), 'viridian')
YELLOW       = ((249, 231,  30), 'yellow')

# For each level, sort by axis
# r -> g -> b -> r -> [...]
TREE = (SEAFOAMGREEN,
    (VIRIDIAN,
        (INDIGO,
            (OLIVE,
                (AVOCADO, None, None),
                (RUFOUS, None, None)
            ),
            (BLUE,
                (CERULEAN, None, None),
                (PURPLE, None, None)
            )
        ),
        (GREY,
            (TAUPE,
                (GREEN, None, None),
                (SAGE, None, None)
            ),
            (GLAUCOUS,
                (VERDIGRIS, None, None),
                (SKYBLUE,
                    None,
                    (CELADON, None, None)
                )
            )
        )
    ),
    (ORANGE,
        (VERMILION,
            (FULVOUS,
                (OCHRE, None, None),
                (RED, None, None)
            ),
            (SCARLET,
                (PUCE, None, None),
                (FUCHSIA,
                    None,
                    (CORAL, None, None)
                )
            )
        ),
        (ECRU,
            (YELLOW,
                (CHARTREUSE, None, None),
                (MAIZE, None, None)
            ),
            (MAUVE,
                (LILAC, None, None),
                (BASTARDAMBER,
                    None,
                    (BISQUE, None, None)
                )
            )
        )
    )
)

def distance_3d(colA, colB):
    """Returns the "Squared Euclidean distance" between two colours."""
    return distance_1d(colA[0], colB[0]) + distance_1d(colA[1], colB[1]) + distance_1d(colA[2], colB[2])

def distance_1d(colA, colB):
    return (colA - colB) ** 2

def find_nearest_colour(colour, tree=None, nearest=None, depth=0):
    """Returns a tuple containing, at the following indexes:
    0 : (r,g,b) tuple value of nearest colour
    1 : Name of nearest colour, acceptable to QLab
    2 : Squared Euclidean distance to input colour
    """
    if not tree:
        tree = TREE

    current_node = tree[0]
    left_branch = tree[1]
    right_branch = tree[2]

    node_3d_distance = distance_3d(colour, current_node[0])
    if nearest is None or node_3d_distance < nearest[2]:
        nearest = (*current_node, node_3d_distance)

    if nearest[2] == 0 or not tree[1] and not tree[2]:
        return nearest

    axis = depth % 3 # 0=r, 1=g, 2=b
    depth += 1

    if colour[axis] < current_node[0][axis]:
        if not left_branch:
            return nearest

        nearest = find_nearest_colour(colour, left_branch, nearest, depth)

        if right_branch:
            right_1d_distance = distance_1d(colour[axis], right_branch[0][0][axis])
            if right_1d_distance < nearest[2]:
                nearest = find_nearest_colour(colour, right_branch, nearest, depth)

    else:
        if not right_branch:
            return nearest

        nearest = find_nearest_colour(colour, right_branch, nearest, depth)

        if left_branch:
            left_1d_distance = distance_1d(colour[axis], left_branch[0][0][axis])
            if left_1d_distance < nearest[2]:
                nearest = find_nearest_colour(colour, left_branch, nearest, depth)

    return nearest
