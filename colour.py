# -*- coding: utf-8 -*-
#
# This file is a derivation of work on - and as such shares the same
# licence as - Linux Show Player
#
# Linux Show Player:
#   Copyright 2012-2020 Francesco Ceruti <ceppofrancy@gmail.com>
#
# This file:
#   Copyright 2020 s0600204
#
# Linux Show Player is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Linux Show Player is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Linux Show Player.  If not, see <http://www.gnu.org/licenses/>.

"""
Whilst LiSP can display it's cues using any colour of the rainbow, QLab cannot. Instead, it has
a palette of (no doubt carefully chosen) colours that users may choose from.

Thus, we need to map a user's arbitrary cue colour choice to one contained within QLab's
palette.

Instead of comparing against every possible colour QLab uses, we instead use a "k-dimensional
tree" to store values in, which allows us to take a divide-and-conquer approach to finding the
nearest palette colour.

The k-d tree is generated by hand, as the colour range used by QLab is simple (thus easy for a
human to generate) and does not change mid-program (so we don't need to add, insert, or remove
entries programmatically).

Links:
* https://en.wikipedia.org/wiki/K-d_tree
* https://en.wikipedia.org/wiki/Euclidean_distance
* https://qlab.app/docs/v4/scripting/osc-dictionary-v4/#cuecue_numbercolorname-string
"""

# The colours QLab uses.
#
# Names were discovered by comparing against the list of colours compiled by Randall Munroe (of
# xkcd), obtainable from https://blog.xkcd.com/2010/05/03/color-survey-results/ (License: CC-0).
#
# RGB values are also taken from the survey, and as such might not match QLab exactly.
#
# Note: We don't provide a value for QLab colour 'none', as that's unnecessary - if a user
#       hasn't set (or has cleared) a colour in LiSP, then `find_nearest_colour()` isn't called.
AVOCADO    = ((144, 177,  52), 'avocado')
BLUE       = ((  3,  67, 233), 'blue')
CELADON    = ((190, 253, 183), 'celadon')
CERULEAN   = ((  4, 133, 209), 'cerulean')
CHARTREUSE = ((193, 248,  10), 'chartreuse')
CORAL      = ((252,  90,  80), 'coral')
ECRU       = ((254, 255, 202), 'ecru')
FUCHSIA    = ((237,  13, 217), 'fuchsia')
GREEN      = (( 21, 176,  26), 'green')
GREY       = ((146, 149, 145), 'grey')
INDIGO     = (( 56,   2, 130), 'indigo')
LILAC      = ((206, 162, 253), 'lilac')
MAIZE      = ((244, 208,  84), 'maize')
MAUVE      = ((174, 113, 129), 'mauve')
OCHRE      = ((191, 144,   5), 'ochre')
OLIVE      = ((110, 117,  14), 'olive')
ORANGE     = ((249, 115,   6), 'orange')
PUCE       = ((165, 126,  82), 'puce')
PURPLE     = ((126,  30, 156), 'purple')
RED        = ((229,   0,   0), 'red')
SAGE       = ((135, 174, 115), 'sage')
SCARLET    = ((190,   1,  25), 'scarlet')
TAUPE      = ((185, 162, 129), 'taupe')
VIRIDIAN   = (( 30, 145, 103), 'viridian')
YELLOW     = ((255, 255,  20), 'yellow')

# For each level, sort by axis
# r -> g -> b -> r -> [...]
TREE = (TAUPE,
	(PUCE,
		(INDIGO,
			(OLIVE,
				None,
				(MAUVE, None, None)
			),
			(PURPLE,
				(BLUE, None, None),
				None,
			)
		),
		(VIRIDIAN,
			(GREEN,
				None,
				(AVOCADO, None, None)
			),
			(SAGE,
				(CERULEAN, None, None),
				(GREY, None, None)
			)
		)
	),
	(OCHRE,
		(SCARLET,
			(RED,
				None,
				(ORANGE, None, None)
			),
			(CORAL,
				(FUCHSIA, None, None),
				None
			)
		),
		(MAIZE,
			(CHARTREUSE,
				None,
				(YELLOW, None, None)
			),
			(LILAC,
				(CELADON, None, None),
				(ECRU, None, None)
			)
		)
	)
)

def distance_3d(colA, colB):
    """Returns the "Squared Euclidean distance" between two colours."""
    return distance_1d(colA[0], colB[0]) + distance_1d(colA[1], colB[1]) + distance_1d(colA[2], colB[2])

def distance_1d(colA, colB):
    return (colA - colB) ** 2

def find_nearest_colour(colour, tree=None, nearest=None, depth=0):
    """Returns a tuple containing, at the following indexes:
    0 : (r,g,b) tuple value of nearest colour
    1 : Name of nearest colour, acceptable to QLab
    2 : Squared Euclidean distance to input colour
    """
    if not tree:
        tree = TREE

    current_node = tree[0]
    left_branch = tree[1]
    right_branch = tree[2]

    node_3d_distance = distance_3d(colour, current_node[0])
    if nearest is None or node_3d_distance < nearest[2]:
        nearest = (*current_node, node_3d_distance)

    if nearest[2] == 0 or not tree[1] and not tree[2]:
        return nearest

    axis = depth % 3 # 0=r, 1=g, 2=b
    depth += 1

    if colour[axis] < current_node[0][axis]:
        if not left_branch:
            return nearest

        nearest = find_nearest_colour(colour, left_branch, nearest, depth)

        if right_branch:
            right_1d_distance = distance_1d(colour[axis], right_branch[0][0][axis])
            if right_1d_distance < nearest[2]:
                nearest = find_nearest_colour(colour, right_branch, nearest, depth)

    else:
        if not right_branch:
            return nearest

        nearest = find_nearest_colour(colour, right_branch, nearest, depth)

        if left_branch:
            left_1d_distance = distance_1d(colour[axis], left_branch[0][0][axis])
            if left_1d_distance < nearest[2]:
                nearest = find_nearest_colour(colour, left_branch, nearest, depth)

    return nearest
